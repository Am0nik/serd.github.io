<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Сердце для подруги</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: black;
        }
        canvas {
            display: block;
        }
    </style>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
</head>
<body>
    <script>
        let scene = new THREE.Scene();
        let camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        let renderer = new THREE.WebGLRenderer();
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);

        let positions = [];
        let originalPositions = [];
        let material = new THREE.PointsMaterial({ color: 0xff0000, size: 0.15 });

        function heartShape(a, r) {
            let x = r * (16 * Math.pow(Math.sin(a), 3));
            let y = r * (13 * Math.cos(a) - 5 * Math.cos(2 * a) - 2 * Math.cos(3 * a) - Math.cos(4 * a));
            return [x * 0.3, y * 0.3, (Math.random() - 0.5) * 2];
        }

        for (let i = 0; i < 60000; i++) {
            let t = Math.random() * Math.PI * 2;
            let r = Math.random() * 0.7 + 0.8;
            let point = heartShape(t, r);
            positions.push(...point);
            originalPositions.push(...point);
        }

        let geometry = new THREE.BufferGeometry();
        let positionsArray = new Float32Array(positions);
        geometry.setAttribute('position', new THREE.BufferAttribute(positionsArray, 3));

        let pointCloud = new THREE.Points(geometry, material);
        scene.add(pointCloud);

        camera.position.z = 25;

        function animate() {
            requestAnimationFrame(animate);
            let positions = geometry.attributes.position.array;
            for (let i = 0; i < positions.length; i += 3) {
                positions[i] += (originalPositions[i] - positions[i]) * 0.02;
                positions[i + 1] += (originalPositions[i + 1] - positions[i + 1]) * 0.02;
            }
            geometry.attributes.position.needsUpdate = true;
            renderer.render(scene, camera);
        }
        animate();

        document.addEventListener("mousemove", (event) => {
            let mouseX = (event.clientX / window.innerWidth) * 2 - 1;
            let mouseY = -(event.clientY / window.innerHeight) * 2 + 1;
            let positions = geometry.attributes.position.array;
            for (let i = 0; i < positions.length; i += 3) {
                let dx = positions[i] - mouseX * 10;
                let dy = positions[i + 1] - mouseY * 10;
                let dist = Math.sqrt(dx * dx + dy * dy);
                if (dist < 1.5) {
                    positions[i] += dx * 0.05;
                    positions[i + 1] += dy * 0.05;
                }
            }
            geometry.attributes.position.needsUpdate = true;
        });
    </script>
</body>
</html>
